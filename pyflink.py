#!/usr/bin/env python3
import os
from pathlib import Path
import sys
import uuid
import argparse
from utils import TaglistParser
import logging

parser = argparse.ArgumentParser()
parser.add_argument("--name", help="An optional name for the collection of tags")
parser.add_argument("--include", help="Comma separated list of tags that will be included, combined with AND")
parser.add_argument("--exclude", help="Comma separated list of tags that will be excluded, combined with AND")
parser.add_argument('--searchpath', type=Path, default=Path().cwd())
parser.add_argument( '-log',
                     '--loglevel',
                     default='warning',
                     help='Provide logging level. Example --loglevel debug, default=warning' )
args = parser.parse_args()
logging.basicConfig( level=args.loglevel.upper() )


include_tags = TaglistParser(args.include)
exclude_tags = TaglistParser(args.exclude)

if not include_tags and not exclude_tags:
    raise Exception("'--include' XOR '--exclude' options are required!")

if tag_overlap := include_tags.intersection(exclude_tags):
    raise Exception(f"Tag overlap between 'include' and 'excldue': {tag_overlap}")

 
Suchpfad: Path = args.searchpath
logging.debug(f"Searchpath is {Suchpfad}")

 
# Alle Dateien auflisten
alle_dateien = [PO for PO in Suchpfad.rglob("*") if PO.is_file() and not PO.is_symlink()]
fundstellen: list[Path] = []


for dateipfad in alle_dateien:
    logging.debug(f"Check {dateipfad = }")
    try:
        ist_tags = set(os.getxattr(dateipfad, attribute="user.xdg.tags").decode("utf8").split(","))
        logging.debug(f"File has those tags: {ist_tags = }")

        if exclude_find := ist_tags.intersection(exclude_tags):
            logging.debug(f"File has tags that are to be excluded: {exclude_find}")
            continue

        if include_find := include_tags.intersection(ist_tags):
            logging.debug(f"File has tags that are to be included: {include_find}")
            fundstellen.append(dateipfad)

    except OSError:
        pass

 

 

if not fundstellen:
    logging.info("No suitable files found")
    sys.exit(0)

 

if not args.name:
    incl_part = "_".join(sorted(list(include_tags)))

    if exclude_tags:
        excl_part = "EXCLUDING_" + "_".join(sorted(list(exclude_tags)))
    else:
        excl_part = ""

    collection_name = f"{incl_part}{excl_part}"
    logging.debug(f"No collection name given; Autogenerated from tags")

else:
    collection_name = args.name
    logging.debug(f"Collection name given")



 

Ablagepfad = Path("tags").joinpath(collection_name)
logging.info(f"Creating {len(fundstellen)} symlinks in '{Ablagepfad}'")

 

if Ablagepfad.exists():
    logging.info(f"{Ablagepfad} already contains links. Removing them...")
    for PO in Ablagepfad.rglob("*"):
        PO.unlink()

 

Ablagepfad.mkdir(parents=True, exist_ok=True)

 

for fundstelle in fundstellen:
    link_pfad = Ablagepfad.joinpath(fundstelle.name)

    if link_pfad.exists():
        suffix = str(uuid.uuid4())[:5]
        link_pfad = link_pfad.with_name(link_pfad.name + "_" + suffix)
        logging.debug(f"Duplicate filename found {link_pfad.name}, adding random suffix {suffix}")

    symlink_pfad = Path(fundstelle.absolute()).relative_to(Ablagepfad.absolute(), walk_up=True)
    Path(link_pfad).symlink_to(symlink_pfad)
    logging.debug(f"{symlink_pfad} --> {link_pfad}")
